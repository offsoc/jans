use super::{
    super::cedar_schema::CedarSchemaJson, parse_maybe_cedar_version, parse_option_string,
    trusted_issuer_metadata::TrustedIssuerMetadata, CedarSchema, PolicyStore, TokenKind,
    TrustedIssuer,
};
use base64::prelude::*;
use cedar_policy::{
    ffi::{self},
    Policy, PolicyId, PolicySet, Schema,
};
use semver::Version;
use serde::{de, Deserialize, Deserializer};
use std::{collections::HashMap, str::FromStr};

#[derive(Debug, thiserror::Error)]
pub enum PolicyStoreError {
    #[error("Failed to load policy store from JSON: {0:?}")]
    LoadFromJson(#[from] PolicyStoreJsonError),
    #[error("Failed to load policy store from YAML: {0:?}")]
    LoadFromYaml(#[from] PolicyStoreYamlError),
}

#[derive(Debug, thiserror::Error)]
pub enum PolicyStoreJsonError {
    #[error("The JSON policy stores does not contain a single policy store.")]
    NoPolicyStore,
    #[error("The JSON policy stores contain more than one policy store.")]
    MoreThanOnePolicyStore,
    #[error("Failed to load policy store from JSON: {0:?}")]
    Deserialization(serde_json::Error),
}

#[derive(Debug, thiserror::Error)]
pub enum PolicyStoreYamlError {
    #[error("Failed to load policy store from YAML: {0:?}")]
    Deserialization(serde_yml::Error),
}

// Policy Stores from the Agama Policy Designer
#[derive(Debug, PartialEq)]
#[allow(dead_code)]
pub struct AgamaPolicyStore {
    pub name: String,
    pub description: Option<String>,
    pub cedar_version: Option<Version>,
    pub policies: HashMap<String, AgamaPolicyContent>,
    pub cedar_schema: CedarSchema,
    pub trusted_issuers: HashMap<String, TrustedIssuerMetadata>,
}

impl AgamaPolicyStore {
    pub fn load_from_json(json: &str) -> Result<Self, PolicyStoreError> {
        let json_store = serde_json::from_str::<PolicyStoreJson>(&json)
            .map_err(PolicyStoreJsonError::Deserialization)?;
        json_store
            .try_into()
            .map_err(PolicyStoreError::LoadFromJson)
    }

    pub fn load_from_yaml(yaml: &str) -> Result<Self, PolicyStoreError> {
        let yaml_store = serde_yml::from_str::<PolicyStoreYaml>(&yaml)
            .map_err(PolicyStoreYamlError::Deserialization)?;
        Ok(yaml_store.into())
    }
}

// Policy Store from the Agama Policy Designer
#[derive(Debug, PartialEq)]
pub struct AgamaPolicyContent {
    pub description: String,
    pub creation_date: String,
    pub policy_content: Policy,
}

/// Policy Store generated by Agama Lab.
#[derive(Deserialize)]
struct PolicyStoreJson {
    #[serde(deserialize_with = "parse_maybe_cedar_version")]
    cedar_version: Option<Version>,
    policy_stores: HashMap<String, PolicyStoreDataJson>,
}

impl TryFrom<PolicyStoreJson> for AgamaPolicyStore {
    type Error = PolicyStoreJsonError;

    fn try_from(json_store: PolicyStoreJson) -> Result<Self, Self::Error> {
        match json_store.policy_stores.len() {
            0 => Err(PolicyStoreJsonError::NoPolicyStore),
            1 => {
                let (_id, store) = json_store
                    .policy_stores
                    .into_iter()
                    .next()
                    .expect("Should have one policy store");
                Ok(Self {
                    name: store.name,
                    description: store.description,
                    cedar_version: json_store.cedar_version,
                    policies: store.policies,
                    cedar_schema: store.cedar_schema,
                    trusted_issuers: store.trusted_issuers,
                })
            },
            _ => Err(PolicyStoreJsonError::MoreThanOnePolicyStore),
        }
    }
}

#[derive(Debug, PartialEq, Deserialize)]
#[allow(dead_code)]
pub struct PolicyStoreDataJson {
    pub name: String,
    #[serde(deserialize_with = "parse_option_string")]
    pub description: Option<String>,
    #[serde(deserialize_with = "parse_encoded_policies")]
    pub policies: HashMap<String, AgamaPolicyContent>,
    #[serde(alias = "schema", deserialize_with = "parse_encoded_schema")]
    pub cedar_schema: CedarSchema,
    pub trusted_issuers: HashMap<String, TrustedIssuerMetadata>,
}

/// Policy Store used for internal testing which supports readable
/// Cedar policies and schema.
#[derive(Deserialize)]
struct PolicyStoreYaml {
    pub name: String,
    #[serde(deserialize_with = "parse_option_string")]
    pub description: Option<String>,
    #[serde(deserialize_with = "parse_maybe_cedar_version")]
    pub cedar_version: Option<Version>,
    #[serde(deserialize_with = "parse_human_readable_policies")]
    pub policies: HashMap<String, AgamaPolicyContent>,
    #[serde(alias = "schema", deserialize_with = "parse_human_readable_schema")]
    pub cedar_schema: CedarSchema,
    pub trusted_issuers: HashMap<String, TrustedIssuerMetadata>,
}

impl From<PolicyStoreYaml> for AgamaPolicyStore {
    fn from(yaml_store: PolicyStoreYaml) -> Self {
        Self {
            name: yaml_store.name,
            description: yaml_store.description,
            cedar_version: yaml_store.cedar_version,
            policies: yaml_store.policies,
            cedar_schema: yaml_store.cedar_schema,
            trusted_issuers: yaml_store.trusted_issuers,
        }
    }
}

// Parse a Hashmap of Base64 encoded Cedar policies
fn parse_encoded_policies<'de, D>(
    deserializer: D,
) -> Result<HashMap<String, AgamaPolicyContent>, D::Error>
where
    D: Deserializer<'de>,
{
    #[derive(Deserialize)]
    struct RawPolicy {
        description: String,
        creation_date: String,
        /// Base64 encoded JSON Cedar Policy
        #[serde(rename = "policy_content")]
        encoded_policy: String,
    }

    let raw_policies = <HashMap<String, RawPolicy> as de::Deserialize>::deserialize(deserializer)?;
    let mut policies = HashMap::new();

    for (policy_id, policy) in raw_policies {
        // parse the decoded policy string into a cedar_policy::Policy struct
        let decoded_policy = decode_b64_string::<D>(policy.encoded_policy)?;
        let cedar_policy = Policy::parse(Some(PolicyId::new(&policy_id)), decoded_policy)
            .map_err(de::Error::custom)?;

        let agama_policy = AgamaPolicyContent {
            description: policy.description,
            creation_date: policy.creation_date,
            policy_content: cedar_policy,
        };

        policies.insert(policy_id, agama_policy);
    }

    Ok(policies)
}

// Parse a Hashmap of Human-redable Cedar policies
fn parse_human_readable_policies<'de, D>(
    deserializer: D,
) -> Result<HashMap<String, AgamaPolicyContent>, D::Error>
where
    D: Deserializer<'de>,
{
    #[derive(Deserialize)]
    struct RawPolicy {
        description: String,
        creation_date: String,
        #[serde(rename = "policy_content")]
        cedar_policy: String,
    }

    let raw_policies = <HashMap<String, RawPolicy> as de::Deserialize>::deserialize(deserializer)?;
    let mut policies = HashMap::new();

    for (policy_id, policy) in raw_policies {
        // parse the decoded policy string into a cedar_policy::Policy struct
        let cedar_policy = Policy::parse(Some(PolicyId::new(&policy_id)), policy.cedar_policy)
            .map_err(de::Error::custom)?;

        let agama_policy = AgamaPolicyContent {
            description: policy.description,
            creation_date: policy.creation_date,
            policy_content: cedar_policy,
        };

        policies.insert(policy_id, agama_policy);
    }

    Ok(policies)
}

// Parse a Base64 encoded Cedar schema
fn parse_encoded_schema<'de, D>(deserializer: D) -> Result<CedarSchema, D::Error>
where
    D: Deserializer<'de>,
{
    let encoded_schema = String::deserialize(deserializer)?;
    let decoded_schema = decode_b64_string::<D>(encoded_schema)?;
    let schema = Schema::from_json_str(&decoded_schema)
        .map_err(|e| de::Error::custom(format!("Failed to load Schema from JSON: {:?}", e)))?;
    let json = serde_json::from_str::<CedarSchemaJson>(&decoded_schema).map_err(|e| {
        de::Error::custom(format!("Failed to Load CedarSchemaJson from JSON: {:?}", e))
    })?;
    Ok(CedarSchema { schema, json })
}

// Parse a human-readable Cedar schema
fn parse_human_readable_schema<'de, D>(deserializer: D) -> Result<CedarSchema, D::Error>
where
    D: Deserializer<'de>,
{
    let cedar_schema = String::deserialize(deserializer)?;
    let schema = Schema::from_str(&cedar_schema)
        .map_err(|e| de::Error::custom(format!("Failed to load Schema from JSON: {:?}", e)))?;

    // we convert the Schema to a JSON format because it's needed for the
    // rest of the code.
    let ffi_schema = ffi::Schema::Cedar(cedar_schema.clone());
    let ffi_json_schema = match ffi::schema_to_json(ffi_schema) {
        ffi::SchemaToJsonAnswer::Success { json, .. } => json,
        ffi::SchemaToJsonAnswer::Failure { errors } => {
            return Err(de::Error::custom(format!(
                "Error converting Cedar schema to JSON: {:?}",
                errors
            )))
        },
    };
    let json = serde_json::to_string(&ffi_json_schema).unwrap();
    // println!("\n{}\n", json);
    let json = serde_json::from_str::<CedarSchemaJson>(&json).map_err(|e| {
        de::Error::custom(format!("Failed to Load CedarSchemaJson from JSON: {:?}", e))
    })?;

    Ok(CedarSchema { schema, json })
}

#[derive(Deserialize)]
struct RawAgamaPolicyStores {
    #[serde(deserialize_with = "parse_maybe_cedar_version")]
    cedar_version: Option<Version>,
    policy_stores: HashMap<String, RawAgamaPolicyStore>,
}

#[derive(Deserialize)]
struct RawAgamaPolicyStore {
    pub name: String,
    #[serde(deserialize_with = "parse_option_string")]
    pub description: Option<String>,
    policies: HashMap<String, RawAgamaCedarPolicy>,
    /// Base64 encoded JSON Cedar Schema
    #[serde(rename = "schema")]
    encoded_schema: String,
    trusted_issuers: HashMap<String, TrustedIssuerMetadata>,
}

#[derive(Deserialize)]
struct RawAgamaCedarPolicy {
    description: String,
    creation_date: String,
    /// Base64 encoded JSON Cedar Policy
    #[serde(rename = "policy_content")]
    encoded_policy: String,
}

fn decode_b64_string<'de, D>(value: String) -> Result<String, D::Error>
where
    D: de::Deserializer<'de>,
{
    let buf = BASE64_STANDARD
        .decode(value)
        .map_err(|e| de::Error::custom(format!("Failed to decode Base64 encoded string: {}", e)))?;
    String::from_utf8(buf)
        .map_err(|e| de::Error::custom(format!("Failed to decode Base64 encoded string: {}", e)))
}

impl<'de> Deserialize<'de> for AgamaPolicyStore {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: de::Deserializer<'de>,
    {
        let raw_policy_stores = RawAgamaPolicyStores::deserialize(deserializer)?;
        let mut policies = HashMap::new();

        // We use a loop here to get the first item in the HashMap.
        for (_policy_store_id, policy_store) in raw_policy_stores.policy_stores {
            for (policy_id, policy) in policy_store.policies {
                // parse the decoded policy string into a cedar_policy::Policy struct
                let decoded_policy = decode_b64_string::<D>(policy.encoded_policy)?;
                let cedar_policy = Policy::parse(Some(PolicyId::new(&policy_id)), decoded_policy)
                    .map_err(de::Error::custom)?;

                let agama_policy = AgamaPolicyContent {
                    description: policy.description,
                    creation_date: policy.creation_date,
                    policy_content: cedar_policy,
                };

                policies.insert(policy_id, agama_policy);
            }

            let name = policy_store.name;

            // Deserialize Base64 encoded schema into CedarSchema
            let decoded_schema = decode_b64_string::<D>(policy_store.encoded_schema)?;
            let schema = Schema::from_json_str(&decoded_schema).map_err(de::Error::custom)?;
            let json = serde_json::from_str::<CedarSchemaJson>(&decoded_schema)
                .map_err(de::Error::custom)?;
            let cedar_schema = CedarSchema { schema, json };

            // We return early since should only be getting one policy
            // store from Agama and Cedarling only supports using
            // one policy store at a time.
            return Ok(AgamaPolicyStore {
                name,
                description: policy_store.description,
                cedar_version: raw_policy_stores.cedar_version,
                policies,
                cedar_schema,
                trusted_issuers: policy_store.trusted_issuers,
            });
        }

        return Err(de::Error::custom(
            "Failed to deserialize Agama Policy Store: No policy store found in the `policies` field.",
        ));
    }
}

impl From<AgamaPolicyStore> for PolicyStore {
    fn from(agama_store: AgamaPolicyStore) -> Self {
        let mut policy_set = PolicySet::new();
        for (_id, policy) in agama_store.policies {
            policy_set
                .add(policy.policy_content)
                .expect("A non-template linked policy should be used");
        }

        let mut trusted_issuers = Vec::new();
        // we lose the issuer id in this operation so we probably
        // need to update the main policy store as well so wen can log that
        for (_iss_id, iss_metadata) in agama_store.trusted_issuers {
            let mut token_metadata = HashMap::new();
            token_metadata.insert(TokenKind::Access, iss_metadata.access_tokens);
            token_metadata.insert(TokenKind::Id, iss_metadata.id_tokens);
            token_metadata.insert(TokenKind::Userinfo, iss_metadata.userinfo_tokens);
            token_metadata.insert(TokenKind::Transaction, iss_metadata.tx_tokens);

            trusted_issuers.push(TrustedIssuer {
                name: iss_metadata.name,
                description: iss_metadata.description,
                openid_configuration_endpoint: iss_metadata.openid_configuration_endpoint,
                token_metadata: Some(token_metadata),
            });
        }

        PolicyStore {
            name: Some(agama_store.name),
            description: agama_store.description,
            cedar_version: agama_store.cedar_version,
            cedar_schema: agama_store.cedar_schema,
            cedar_policies: policy_set,
            trusted_issuers: Some(trusted_issuers),
        }
    }
}

#[cfg(test)]
mod test {
    use super::super::super::{cedar_schema::CedarSchemaJson, policy_store::CedarSchema};
    use super::{AgamaPolicyContent, AgamaPolicyStore};
    use crate::common::policy_store::agama_policy_store::{
        parse_encoded_policies, parse_encoded_schema, parse_human_readable_policies,
        parse_human_readable_schema,
    };
    use base64::prelude::*;
    use cedar_policy::{ffi, Policy, PolicyId, Schema};
    use serde::Deserialize;
    use serde_json::json;
    use std::collections::HashMap;
    use std::str::FromStr;
    use test_utils::assert_eq;

    fn load_from_cedar_schema_from_str(cedar_schema: &str) -> (CedarSchema, String) {
        let schema = Schema::from_str(&cedar_schema).expect("Should load Schema from str.");

        let ffi_schema = ffi::Schema::Cedar(cedar_schema.to_string());
        let ffi_json_schema = match ffi::schema_to_json(ffi_schema) {
            ffi::SchemaToJsonAnswer::Success { json, .. } => json,
            ffi::SchemaToJsonAnswer::Failure { .. } => {
                panic!("Should convert schema from Cedar format to JSON")
            },
        };
        let json_schema = serde_json::to_string(&ffi_json_schema)
            .expect("Should serialize schema to JSON string");
        let json = serde_json::from_str::<CedarSchemaJson>(&json_schema)
            .expect("Should deserialize JSON schema to CedarSchemaJSON");

        (CedarSchema { schema, json }, json_schema)
    }

    #[test]
    fn can_load_from_json() {
        let policy_store_json = include_str!("./test_agama_policy_store.json");

        // we're already testing if the data gets load properly from the other tests
        // so we just check if this function does not throw an error when reading the
        // whole policy store
        assert!(AgamaPolicyStore::load_from_json(&policy_store_json).is_ok());
    }

    #[test]
    fn can_load_from_yaml() {
        let policy_store_yaml = include_str!("./test_policy_store.yaml");

        // we're already testing if the data gets load properly from the other tests
        // so we just check if this function does not throw an error when reading the
        // whole policy store
        assert!(AgamaPolicyStore::load_from_yaml(&policy_store_yaml).is_ok());
    }

    #[test]
    fn can_parse_encoded_policies() {
        #[derive(Deserialize, Debug, PartialEq)]
        struct TestPolicy {
            #[serde(deserialize_with = "parse_encoded_policies")]
            pub policies: HashMap<String, AgamaPolicyContent>,
        }

        // Create Expected policies
        let mut policies = HashMap::new();
        let policy_id = "some_policy_id".to_string();
        policies.insert(
            policy_id.clone(),
            AgamaPolicyContent {
                description: "Admin".to_string(),
                creation_date: "2024-11-07T07:49:11.813002".to_string(),
                policy_content: Policy::parse(
                    Some(PolicyId::new(policy_id)),
                    r#"@id("Admin")
permit
(
 principal == somecompany::store::Role::"Admin",
 action in [somecompany::store::Action::"DELETE",somecompany::store::Action::"GET",somecompany::store::Action::"PUT"],
 resource == somecompany::store::HTTP_Request::"root"
)
;"#.to_string(),
                )
                .expect("should parse cedar policy"),
            },
        );
        let policy_id = "another_policy_id".to_string();
        policies.insert(
            policy_id.clone(),
            AgamaPolicyContent {
                description: "Member".to_string(),
                creation_date: "2024-11-07T07:50:05.520757".to_string(),
                policy_content: Policy::parse(
                    Some(PolicyId::new(policy_id)),
                    r#"@id("Member")
permit
(
 principal == somecompany::store::Role::"Member",
 action in [somecompany::store::Action::"PUT"],
 resource == somecompany::store::HTTP_Request::"root"
)
;"#
                    .to_string(),
                )
                .expect("should parse cedar policy"),
            },
        );
        let expected = TestPolicy { policies };

        let json_policies = json!({
            "policies": {
                "some_policy_id": {
                    "description": "Admin",
                    "creation_date": "2024-11-07T07:49:11.813002",
                    "policy_content": "QGlkKCJBZG1pbiIpCnBlcm1pdAooCiBwcmluY2lwYWwgPT0gc29tZWNvbXBhbnk6OnN0b3JlOjpSb2xlOjoiQWRtaW4iLAogYWN0aW9uIGluIFtzb21lY29tcGFueTo6c3RvcmU6OkFjdGlvbjo6IkRFTEVURSIsc29tZWNvbXBhbnk6OnN0b3JlOjpBY3Rpb246OiJHRVQiLHNvbWVjb21wYW55OjpzdG9yZTo6QWN0aW9uOjoiUFVUIl0sCiByZXNvdXJjZSA9PSBzb21lY29tcGFueTo6c3RvcmU6OkhUVFBfUmVxdWVzdDo6InJvb3QiCikKOw=="
                },
                "another_policy_id": {
                    "description": "Member",
                    "creation_date": "2024-11-07T07:50:05.520757",
                    "policy_content": "QGlkKCJNZW1iZXIiKQpwZXJtaXQKKAogcHJpbmNpcGFsID09IHNvbWVjb21wYW55OjpzdG9yZTo6Um9sZTo6Ik1lbWJlciIsCiBhY3Rpb24gaW4gW3NvbWVjb21wYW55OjpzdG9yZTo6QWN0aW9uOjoiUFVUIl0sCiByZXNvdXJjZSA9PSBzb21lY29tcGFueTo6c3RvcmU6OkhUVFBfUmVxdWVzdDo6InJvb3QiCikKOw=="
                }
            }
        });

        let parsed_policies = serde_json::from_value::<TestPolicy>(json_policies)
            .expect("Failed to parse policies from JSON");

        assert_eq!(
            parsed_policies, expected,
            "Expected to parse policies correctly"
        );
    }

    #[test]
    fn can_parse_human_readable_policies() {
        #[derive(Deserialize, Debug, PartialEq)]
        struct TestPolicy {
            #[serde(deserialize_with = "parse_human_readable_policies")]
            pub policies: HashMap<String, AgamaPolicyContent>,
        }

        // Create Expected policies
        let mut policies = HashMap::new();
        let policy_id = "some_policy_id".to_string();
        policies.insert(
            policy_id.clone(),
            AgamaPolicyContent {
                description: "Admin".to_string(),
                creation_date: "2024-11-07T07:49:11.813002".to_string(),
                policy_content: Policy::parse(
                    Some(PolicyId::new(policy_id)),
                    r#"@id("Admin")
permit (
 principal == somecompany::store::Role::"Admin",
 action in [somecompany::store::Action::"DELETE",somecompany::store::Action::"GET",somecompany::store::Action::"PUT"],
 resource == somecompany::store::HTTP_Request::"root"
);"#.to_string(),
                )
                .expect("should parse cedar policy"),
            },
        );
        let policy_id = "another_policy_id".to_string();
        policies.insert(
            policy_id.clone(),
            AgamaPolicyContent {
                description: "Member".to_string(),
                creation_date: "2024-11-07T07:50:05.520757".to_string(),
                policy_content: Policy::parse(
                    Some(PolicyId::new(policy_id)),
                    r#"@id("Member")
permit (
 principal == somecompany::store::Role::"Member",
 action in [somecompany::store::Action::"PUT"],
 resource == somecompany::store::HTTP_Request::"root"
);"#
                    .to_string(),
                )
                .expect("should parse cedar policy"),
            },
        );
        let expected = TestPolicy { policies };

        let yaml_policies = r#"policies:
          some_policy_id:
            description: Admin
            creation_date: 2024-11-07T07:49:11.813002
            policy_content: |-
              @id("Admin")
              permit (
               principal == somecompany::store::Role::"Admin",
               action in [somecompany::store::Action::"DELETE",somecompany::store::Action::"GET",somecompany::store::Action::"PUT"],
               resource == somecompany::store::HTTP_Request::"root"
              );
          another_policy_id:
            description: Member
            creation_date: 2024-11-07T07:50:05.520757
            policy_content: |-
              @id("Member")
              permit (
               principal == somecompany::store::Role::"Member",
               action in [somecompany::store::Action::"PUT"],
               resource == somecompany::store::HTTP_Request::"root"
              );"#;

        let parsed_policies = serde_yml::from_str::<TestPolicy>(yaml_policies)
            .expect("Failed to parse policies from YAML");

        assert_eq!(
            parsed_policies, expected,
            "Expected to parse policies correctly"
        );
    }

    #[test]
    fn can_parse_encoded_schema() {
        #[derive(Debug, PartialEq, Deserialize)]
        struct TestPolicyStore {
            #[serde(alias = "schema", deserialize_with = "parse_encoded_schema")]
            pub cedar_schema: CedarSchema,
        }

        let cedar_schema_str = r#"namespace Jans {
    type Url = {"host": String, "path": String, "protocol": String};
    entity Access_token = {"aud": String, "exp": Long, "iat": Long, "iss": TrustedIssuer, "jti": String};
    entity Issue = {"country": String, "org_id": String};
    entity Role;
    entity TrustedIssuer = {"issuer_entity_id": Url};
    entity User in [Role] = {"country": String, "email": String, "sub": String, "username": String};
    entity Workload = {"client_id": String, "iss": TrustedIssuer, "name": String, "org_id": String};
    entity id_token = {"acr": String, "amr": String, "aud": String, "exp": Long, "iat": Long, "iss": TrustedIssuer, "jti": String, "sub": String};
    action "Update" appliesTo {
        principal: [Workload, User, Role],
        resource: [Issue],
        context: {}
    };
}"#;

        let (cedar_schema, json_schema) = load_from_cedar_schema_from_str(cedar_schema_str);
        let expected = TestPolicyStore { cedar_schema };

        let encoded_schema = BASE64_STANDARD.encode(json_schema.as_bytes());
        let json_schema = json!({
            "schema": encoded_schema,
        });

        let parsed = serde_json::from_value::<TestPolicyStore>(json_schema)
            .expect("Failed to parse schema from JSON");

        assert_eq!(
            parsed, expected,
            "Expected to parse encoded schema from JSON correctly"
        );
    }

    #[test]
    fn can_parse_human_readable_schema() {
        #[derive(Debug, PartialEq, Deserialize)]
        struct TestPolicyStore {
            #[serde(alias = "schema", deserialize_with = "parse_human_readable_schema")]
            pub cedar_schema: CedarSchema,
        }

        let cedar_schema_str = r#"namespace Jans {
    type Url = {"host": String, "path": String, "protocol": String};
    entity Access_token = {"aud": String, "exp": Long, "iat": Long, "iss": TrustedIssuer, "jti": String};
    entity Issue = {"country": String, "org_id": String};
    entity Role;
    entity TrustedIssuer = {"issuer_entity_id": Url};
    entity User in [Role] = {"country": String, "email": String, "sub": String, "username": String};
    entity Workload = {"client_id": String, "iss": TrustedIssuer, "name": String, "org_id": String};
    entity id_token = {"acr": String, "amr": String, "aud": String, "exp": Long, "iat": Long, "iss": TrustedIssuer, "jti": String, "sub": String};
    action "Update" appliesTo {
        principal: [Workload, User, Role],
        resource: [Issue],
        context: {}
    };
}"#;

        let (cedar_schema, _) = load_from_cedar_schema_from_str(cedar_schema_str);
        let expected = TestPolicyStore { cedar_schema };

        let yaml_schema = r#"schema: |-
    namespace Jans {
        type Url = {"host": String, "path": String, "protocol": String};
        entity Access_token = {"aud": String, "exp": Long, "iat": Long, "iss": TrustedIssuer, "jti": String};
        entity Issue = {"country": String, "org_id": String};
        entity Role;
        entity TrustedIssuer = {"issuer_entity_id": Url};
        entity User in [Role] = {"country": String, "email": String, "sub": String, "username": String};
        entity Workload = {"client_id": String, "iss": TrustedIssuer, "name": String, "org_id": String};
        entity id_token = {"acr": String, "amr": String, "aud": String, "exp": Long, "iat": Long, "iss": TrustedIssuer, "jti": String, "sub": String};
        action "Update" appliesTo {
            principal: [Workload, User, Role],
            resource: [Issue],
            context: {}
        };
    }"#;

        let parsed = serde_yml::from_str::<TestPolicyStore>(yaml_schema)
            .expect("Failed to parse schema from YAML");

        assert_eq!(
            parsed, expected,
            "Expected to parse schema from YAML correctly"
        );
    }
}

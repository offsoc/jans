use super::{
    super::cedar_schema::CedarSchemaJson, parse_maybe_cedar_version, parse_option_string,
    trusted_issuer_metadata::TrustedIssuerMetadata, CedarSchema, PolicyContent, PolicyStore,
};
use base64::prelude::*;
use cedar_policy::{Policy, PolicyId, PolicySet, Schema};
use semver::Version;
use serde::{de, Deserialize, Deserializer};
use std::collections::HashMap;

/// Policy Store generated by Agama Lab.
#[derive(Deserialize)]
pub struct PolicyStoreJson {
    #[serde(deserialize_with = "parse_maybe_cedar_version")]
    cedar_version: Option<Version>,
    policy_stores: HashMap<String, PolicyStoreDataJson>,
}

impl TryFrom<PolicyStoreJson> for PolicyStore {
    type Error = LoadFromJsonError;

    fn try_from(json_store: PolicyStoreJson) -> Result<Self, Self::Error> {
        match json_store.policy_stores.len() {
            0 => Err(LoadFromJsonError::NoPolicyStore),
            1 => {
                let (_id, store) = json_store
                    .policy_stores
                    .into_iter()
                    .next()
                    .expect("Should have one policy store");

                let mut policy_set = PolicySet::new();
                for (_id, policy) in &store.policies {
                    // this expect should never be called because we defined our
                    // own policies when we parsed the policy store and they
                    // never are template-linked.
                    policy_set
                        .add(policy.policy_content.clone())
                        .expect("Expected a non-template linked policy");
                }

                Ok(Self {
                    name: store.name,
                    description: store.description,
                    cedar_version: json_store.cedar_version,
                    policies: store.policies,
                    cedar_schema: store.cedar_schema,
                    trusted_issuers: store.trusted_issuers,
                    policy_set,
                })
            },
            _ => Err(LoadFromJsonError::MoreThanOnePolicyStore),
        }
    }
}

#[derive(Debug, PartialEq, Deserialize)]
#[allow(dead_code)]
pub struct PolicyStoreDataJson {
    #[serde(deserialize_with = "parse_option_string", default)]
    pub name: Option<String>,
    #[serde(deserialize_with = "parse_option_string", default)]
    pub description: Option<String>,
    #[serde(deserialize_with = "parse_encoded_policies")]
    pub policies: HashMap<String, PolicyContent>,
    #[serde(alias = "schema", deserialize_with = "parse_encoded_schema")]
    pub cedar_schema: CedarSchema,
    #[serde(default)]
    pub trusted_issuers: HashMap<String, TrustedIssuerMetadata>,
}

// Parse a Hashmap of Base64 encoded Cedar policies
fn parse_encoded_policies<'de, D>(
    deserializer: D,
) -> Result<HashMap<String, PolicyContent>, D::Error>
where
    D: Deserializer<'de>,
{
    #[derive(Deserialize)]
    struct RawPolicy {
        description: String,
        creation_date: String,
        /// Base64 encoded JSON Cedar Policy
        #[serde(rename = "policy_content")]
        encoded_policy: String,
    }

    let raw_policies = <HashMap<String, RawPolicy> as de::Deserialize>::deserialize(deserializer)?;
    let mut policies = HashMap::new();

    for (policy_id, policy) in raw_policies {
        // parse the decoded policy string into a cedar_policy::Policy struct
        let decoded_policy = decode_b64_string::<D>(policy.encoded_policy)?;
        let cedar_policy = Policy::parse(Some(PolicyId::new(&policy_id)), decoded_policy)
            .map_err(de::Error::custom)?;

        let agama_policy = PolicyContent {
            description: policy.description,
            creation_date: policy.creation_date,
            policy_content: cedar_policy,
        };

        policies.insert(policy_id, agama_policy);
    }

    Ok(policies)
}

// Parse a Base64 encoded Cedar schema
fn parse_encoded_schema<'de, D>(deserializer: D) -> Result<CedarSchema, D::Error>
where
    D: Deserializer<'de>,
{
    let encoded_schema = String::deserialize(deserializer)?;
    let decoded_schema = decode_b64_string::<D>(encoded_schema)?;
    let schema = Schema::from_json_str(&decoded_schema)
        .map_err(|e| de::Error::custom(format!("Failed to load Schema from JSON: {:?}", e)))?;
    let json = serde_json::from_str::<CedarSchemaJson>(&decoded_schema).map_err(|e| {
        de::Error::custom(format!("Failed to Load CedarSchemaJson from JSON: {:?}", e))
    })?;
    Ok(CedarSchema { schema, json })
}

fn decode_b64_string<'de, D>(value: String) -> Result<String, D::Error>
where
    D: de::Deserializer<'de>,
{
    let buf = BASE64_STANDARD
        .decode(value)
        .map_err(|e| de::Error::custom(format!("Failed to decode Base64 encoded string: {}", e)))?;
    String::from_utf8(buf)
        .map_err(|e| de::Error::custom(format!("Failed to decode Base64 encoded string: {}", e)))
}

#[derive(Debug, thiserror::Error)]
pub enum LoadFromJsonError {
    #[error("The JSON policy stores does not contain a single policy store.")]
    NoPolicyStore,
    #[error("The JSON policy stores contain more than one policy store.")]
    MoreThanOnePolicyStore,
    #[error("Failed to load policy store from JSON: {0}")]
    Deserialization(serde_json::Error),
}

#[cfg(test)]
mod test {
    use super::super::super::{cedar_schema::CedarSchemaJson, policy_store::CedarSchema};
    use super::super::PolicyContent;
    use super::{parse_encoded_policies, parse_encoded_schema};
    use base64::prelude::*;
    use cedar_policy::{ffi, Policy, PolicyId, Schema};
    use serde::Deserialize;
    use serde_json::json;
    use std::collections::HashMap;
    use std::str::FromStr;
    use test_utils::assert_eq;

    fn load_from_cedar_schema_from_str(cedar_schema: &str) -> (CedarSchema, String) {
        let schema = Schema::from_str(&cedar_schema).expect("Should load Schema from str.");

        let ffi_schema = ffi::Schema::Cedar(cedar_schema.to_string());
        let ffi_json_schema = match ffi::schema_to_json(ffi_schema) {
            ffi::SchemaToJsonAnswer::Success { json, .. } => json,
            ffi::SchemaToJsonAnswer::Failure { .. } => {
                panic!("Should convert schema from Cedar format to JSON")
            },
        };
        let json_schema = serde_json::to_string(&ffi_json_schema)
            .expect("Should serialize schema to JSON string");
        let json = serde_json::from_str::<CedarSchemaJson>(&json_schema)
            .expect("Should deserialize JSON schema to CedarSchemaJSON");

        (CedarSchema { schema, json }, json_schema)
    }

    #[test]
    fn can_parse_encoded_policies() {
        #[derive(Deserialize, Debug, PartialEq)]
        struct TestPolicy {
            #[serde(deserialize_with = "parse_encoded_policies")]
            pub policies: HashMap<String, PolicyContent>,
        }

        // Create Expected policies
        let mut policies = HashMap::new();
        let policy_id = "some_policy_id".to_string();
        policies.insert(
            policy_id.clone(),
            PolicyContent {
                description: "Admin".to_string(),
                creation_date: "2024-11-07T07:49:11.813002".to_string(),
                policy_content: Policy::parse(
                    Some(PolicyId::new(policy_id)),
                    r#"@id("Admin")
permit
(
 principal == somecompany::store::Role::"Admin",
 action in [somecompany::store::Action::"DELETE",somecompany::store::Action::"GET",somecompany::store::Action::"PUT"],
 resource == somecompany::store::HTTP_Request::"root"
)
;"#.to_string(),
                )
                .expect("should parse cedar policy"),
            },
        );
        let policy_id = "another_policy_id".to_string();
        policies.insert(
            policy_id.clone(),
            PolicyContent {
                description: "Member".to_string(),
                creation_date: "2024-11-07T07:50:05.520757".to_string(),
                policy_content: Policy::parse(
                    Some(PolicyId::new(policy_id)),
                    r#"@id("Member")
permit
(
 principal == somecompany::store::Role::"Member",
 action in [somecompany::store::Action::"PUT"],
 resource == somecompany::store::HTTP_Request::"root"
)
;"#
                    .to_string(),
                )
                .expect("should parse cedar policy"),
            },
        );
        let expected = TestPolicy { policies };

        let json_policies = json!({
            "policies": {
                "some_policy_id": {
                    "description": "Admin",
                    "creation_date": "2024-11-07T07:49:11.813002",
                    "policy_content": "QGlkKCJBZG1pbiIpCnBlcm1pdAooCiBwcmluY2lwYWwgPT0gc29tZWNvbXBhbnk6OnN0b3JlOjpSb2xlOjoiQWRtaW4iLAogYWN0aW9uIGluIFtzb21lY29tcGFueTo6c3RvcmU6OkFjdGlvbjo6IkRFTEVURSIsc29tZWNvbXBhbnk6OnN0b3JlOjpBY3Rpb246OiJHRVQiLHNvbWVjb21wYW55OjpzdG9yZTo6QWN0aW9uOjoiUFVUIl0sCiByZXNvdXJjZSA9PSBzb21lY29tcGFueTo6c3RvcmU6OkhUVFBfUmVxdWVzdDo6InJvb3QiCikKOw=="
                },
                "another_policy_id": {
                    "description": "Member",
                    "creation_date": "2024-11-07T07:50:05.520757",
                    "policy_content": "QGlkKCJNZW1iZXIiKQpwZXJtaXQKKAogcHJpbmNpcGFsID09IHNvbWVjb21wYW55OjpzdG9yZTo6Um9sZTo6Ik1lbWJlciIsCiBhY3Rpb24gaW4gW3NvbWVjb21wYW55OjpzdG9yZTo6QWN0aW9uOjoiUFVUIl0sCiByZXNvdXJjZSA9PSBzb21lY29tcGFueTo6c3RvcmU6OkhUVFBfUmVxdWVzdDo6InJvb3QiCikKOw=="
                }
            }
        });

        let parsed_policies = serde_json::from_value::<TestPolicy>(json_policies)
            .expect("Failed to parse policies from JSON");

        assert_eq!(
            parsed_policies, expected,
            "Expected to parse policies correctly"
        );
    }

    #[test]
    fn can_parse_encoded_schema() {
        #[derive(Debug, PartialEq, Deserialize)]
        struct TestPolicyStore {
            #[serde(alias = "schema", deserialize_with = "parse_encoded_schema")]
            pub cedar_schema: CedarSchema,
        }

        let cedar_schema_str = r#"namespace Jans {
    type Url = {"host": String, "path": String, "protocol": String};
    entity Access_token = {"aud": String, "exp": Long, "iat": Long, "iss": TrustedIssuer, "jti": String};
    entity Issue = {"country": String, "org_id": String};
    entity Role;
    entity TrustedIssuer = {"issuer_entity_id": Url};
    entity User in [Role] = {"country": String, "email": String, "sub": String, "username": String};
    entity Workload = {"client_id": String, "iss": TrustedIssuer, "name": String, "org_id": String};
    entity id_token = {"acr": String, "amr": String, "aud": String, "exp": Long, "iat": Long, "iss": TrustedIssuer, "jti": String, "sub": String};
    action "Update" appliesTo {
        principal: [Workload, User, Role],
        resource: [Issue],
        context: {}
    };
}"#;

        let (cedar_schema, json_schema) = load_from_cedar_schema_from_str(cedar_schema_str);
        let expected = TestPolicyStore { cedar_schema };

        let encoded_schema = BASE64_STANDARD.encode(json_schema.as_bytes());
        let json_schema = json!({
            "schema": encoded_schema,
        });

        let parsed = serde_json::from_value::<TestPolicyStore>(json_schema)
            .expect("Failed to parse schema from JSON");

        assert_eq!(
            parsed, expected,
            "Expected to parse encoded schema from JSON correctly"
        );
    }
}
